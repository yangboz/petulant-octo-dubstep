<?xml version="1.0" encoding="utf-8"?>
<views:ViewBase xmlns:fx="http://ns.adobe.com/mxml/2009" 
				xmlns:s="library://ns.adobe.com/flex/spark" 
				xmlns:mx="library://ns.adobe.com/flex/mx" 
				xmlns:views="views.*" width="800" height="600" 
				xmlns:components="views.components.*"
				xmlns:view="com.vstyran.transform.view.*" 
				xmlns:model="com.vstyran.transform.model.*" 
				xmlns:spark="de.patrickheinzelmann.components.spark.*"
				>
	<fx:Script>
		<![CDATA[
			import com.vstyran.transform.consts.GuidelineType;
			import com.vstyran.transform.consts.TransformationType;
			import com.vstyran.transform.events.GuidelineEvent;
			import com.vstyran.transform.events.TransformEvent;
			import com.vstyran.transform.model.Guideline;
			import com.vstyran.transform.skins.TransformToolSkin;
			import com.vstyran.transform.utils.DataUtil;
			
			import model.AppData;
			
			import mx.controls.sliderClasses.Slider;
			import mx.core.IVisualElement;
			import mx.events.FlexEvent;
			import mx.graphics.ImageSnapshot;
			import mx.graphics.codec.JPEGEncoder;
			import mx.graphics.codec.PNGEncoder;
			
			import spark.effects.Rotate;
			import spark.events.IndexChangeEvent;
			//UITransformTools: @see http://vstyran-flex.ho.ua/
//			private var img_editor_width:Number;
			private function get img_editor_width():Number
			{
				return (AppData.ARRAY_SIZE_CERTS[AppData.selectedCertSizeIndex] as Point).x;
			}
			
//			private var img_editor_height:Number;
			private function get img_editor_height():Number
			{
				return (AppData.ARRAY_SIZE_CERTS[AppData.selectedCertSizeIndex] as Point).y;
			}
			
			override protected function creationCompleteHandler(event:FlexEvent):void
			{
				///Display image_editor
				this.id_image_edit.source = AppData.uploadedImageFile.nativePath;
				this.id_image_edit.addEventListener(Event.COMPLETE,function(event:Event):void{
					selectUITransformTool(new MouseEvent(MouseEvent.CLICK));
				});
				///Upldate UI images.
				this.updateImageViews();
				//Update tool
				this.updateUITransformTools();
				///
//				this.addEventListener(MouseEvent.CLICK,deselectUITransformTool);
			}
			
			override protected function id_list_changeHandler(event:IndexChangeEvent):void
			{
				super.id_list_changeHandler(event);
				//
//				AppData.mainApp.id_viewStack.selectedIndex = AppData.VIEW_VERIFING;
				///Upldate UI images.
				this.updateImageViews();
				//Update tool
				this.updateUITransformTools();
			}
			
			override public function get viewBackgroundImage():Bitmap
			{
				return new AppData.BG_IMG_01() as Bitmap;
			}
			
			private function updateImageViews():void
			{
				//
				this.id_image_instruction.source = AppData.ARRAY_INS_CERT_TEXTS[AppData.selectedCertSizeIndex];
				//
				this.id_image_frame.source = AppData.ARRAY_EDITOR_PHOTO_FRAMES[AppData.selectedCertSizeIndex];
				this.id_image_guide.source = AppData.ARRAY_EDITOR_PHOTO_GUIDES[AppData.selectedCertSizeIndex];
				this.id_image_mask.source = AppData.ARRAY_EDITOR_PHOTO_GUIDES[AppData.selectedCertSizeIndex];
				//Mask
//				id_image_edit.mask = id_image_mask;
				//Image group
				this.id_group.width = this.getRequiredCertPhotoWidth();
				this.id_group.height = this.getRequiredCertPhotoHeight();
			}
			
			protected function reupload_button_clickHandler(event:MouseEvent):void
			{
				AppData.mainApp.id_viewStack.selectedIndex = AppData.VIEW_UPLOAD;			
			}
			
			protected function editnext_button_clickHandler(event:MouseEvent):void
			{
				//Save transformed image here:
				trace(id_uit_tool);
				//Transformed maxtrix calculate
				var transformMat:Matrix=new Matrix();
				transformMat.scale(0.7,0.7);
//				transformMat.translate(30,40);
				transformMat.rotate(10);
				//Draw bitmap data, then save to file
				var bitMapData:BitmapData = new BitmapData(this.getRequiredCertPhotoWidth(),this.getRequiredCertPhotoHeight(),true); 
				bitMapData.draw(this.id_image_edit); 
				//
				AppData.saveImageFile(bitMapData);
				//
				AppData.mainApp.id_viewStack.selectedIndex = AppData.VIEW_VERIFING;	
			}
			//
			private function deselectUITransformTool(event:MouseEvent):void
			{
				id_uit_tool.targets = null;
				id_uit_tool.visible = false;
				id_uit_tool.includeInLayout = false;
			}
			
			private function selectUITransformTool(event:MouseEvent):void
			{
				id_uit_tool.targets = [id_image_edit];
				id_uit_tool.visible = true;
				id_uit_tool.includeInLayout = true;
				//UITransformTool
				id_uit_tool.width = id_image_edit.bitmapData.width;
				id_uit_tool.height = id_image_edit.bitmapData.height;
			}
			
			private function onEditorScaleSliderChange(event:Event):void
			{
				this.applyZoom(this.id_image_edit,this.id_vslider_scale.value);
				//Update tool
				this.updateUITransformTools();
			}
			private function onEditorRotateSliderChange(event:Event):void
			{
				this.applyRotate(this.id_image_edit,this.id_hslider_rotate.value);
				//Update tool
				this.updateUITransformTools();
			}
			
			protected function rotate90ButtonClickHandler(event:MouseEvent):void
			{
				this.id_hslider_rotate.value += 90;
				this.applyRotate(this.id_image_edit,this.id_hslider_rotate.value);		
			}
			
			protected function zoomInButtonClickHandler(event:MouseEvent):void
			{
				this.id_vslider_scale.value += 0.1; 
				this.applyZoom(this.id_image_edit,this.id_vslider_scale.value);
			}
			
			protected function zoomOutButtonClickHandler(event:MouseEvent):void
			{
				this.id_vslider_scale.value -= 0.1; 
				this.applyZoom(this.id_image_edit,this.id_vslider_scale.value);
			}
			
			private function applyRotate(target:DisplayObject,angle:Number):void
			{
				// Calculate rotation and offsets
				var radians:Number = angle * (Math.PI / 180.0);
				var offsetWidth:Number = target.width/2.0;
				var offsetHeight:Number =  target.height/2.0;
				// Perform rotation
				var matrix:Matrix = new Matrix();
				matrix.translate(-offsetWidth, -offsetHeight);
				matrix.rotate(radians);
				matrix.translate(+offsetWidth, +offsetHeight);
				matrix.concat(this.id_image_edit.transform.matrix);
				target.transform.matrix = matrix; 
				//Update tool
				this.updateUITransformTools();
			}
			private function applyZoom(target:DisplayObject,ratio:Number):void
			{
				target.scaleX = ratio;
				target.scaleY = ratio;
				//Update tool
				this.updateUITransformTools();
			}
			
			protected function tool_transformationCompleteHandler(event:TransformEvent):void
			{
				trace(event);
//				switch(event.transformationType)
//				{
//					case 
//				}
				
			}
			
			private function updateUITransformTools():void
			{
				//Update tool
				this.id_uit_tool.updateTool(true);
				//Update tool guide lines
				var guidelines:Vector.<Guideline> = new Vector.<Guideline>();
				
				for (var i:int = 0; i < id_border_container.numElements; i++) 
				{
					var element:IVisualElement = id_border_container.getElementAt(i);
					
					if(element is Image && id_uit_tool.target != element)
					{
						var box:Rectangle = DataUtil.createData(element as Image).getBoundingBox();
						
						guidelines.push(new Guideline(GuidelineType.VERTICAL_EDGE, box.x, 3));
						guidelines.push(new Guideline(GuidelineType.VERTICAL_CENTER, box.x+box.width/2, 3));
						guidelines.push(new Guideline(GuidelineType.VERTICAL_EDGE, box.x+box.width, 3));
						
						guidelines.push(new Guideline(GuidelineType.HORIZONTAL_EDGE, box.y, 3));
						guidelines.push(new Guideline(GuidelineType.HORIZONTAL_CENTER, box.y+box.height/2, 3));
						guidelines.push(new Guideline(GuidelineType.HORIZONTAL_EDGE, box.y+box.height, 3));
						
						if((element as Image).rotation%90 != 0)
						{
							var guideLine:Guideline = new Guideline(GuidelineType.ROTATION, (element as Image).rotation, 3);
							guideLine.userData = element;
							guidelines.push(guideLine);
						}
					}
				}
				id_uit_tool.guidelines = guidelines;
			}
			protected function tool_guidelinesUpdateHandler(event:GuidelineEvent):void
			{
				if(event.cross && event.cross.vGuideline)
					vGuide.x = event.cross.vGuideline.value;
				vGuide.visible = (event.cross && event.cross.vGuideline);
				
				if(event.cross && event.cross.hGuideline)
					hGuide.y = event.cross.hGuideline.value;
				hGuide.visible = (event.cross && event.cross.hGuideline);
				
				passiveGuideGroup.removeAllElements();
				if(event.cross)
				{
					if(true)
					{
						for each (var vguide:Guideline in event.cross.getVGuidelines()) 
						{
							var vGuideLine:VGuideLine = new VGuideLine();
							vGuideLine.x = vguide.value;
							passiveGuideGroup.addElement(vGuideLine);
						}
						for each (var hguide:Guideline in event.cross.getHGuidelines()) 
						{
							var hGuideLine:HGuideLine = new HGuideLine();
							hGuideLine.y = hguide.value;
							passiveGuideGroup.addElement(hGuideLine);
						}
					}
					
					if(event.transformationType == TransformationType.ROTATE)
					{
						if(event.cross.rGuideline)
						{
							var rTargetGuideLine:RGuideLine = new RGuideLine();
							rTargetGuideLine.update(id_uit_tool.target, passiveGuideGroup);
							passiveGuideGroup.addElement(rTargetGuideLine);
						}
						
						for each (var rguide:Guideline in event.cross.getRGuidelines()) 
						{
							var rGuideLine:RGuideLine = new RGuideLine();
							rGuideLine.update(rguide.userData as Image, passiveGuideGroup);
							passiveGuideGroup.addElement(rGuideLine);
						}
					}
				}
			}	
		]]>
	</fx:Script>
	<fx:Declarations>                                                                                                     
		<fx:Component className="VGuideLine">
			<s:Line alpha="0.1" y="45" height="230">
				<s:stroke>
					<s:SolidColorStroke/>
				</s:stroke>
			</s:Line>
		</fx:Component>                                       
		<fx:Component className="HGuideLine">
			<s:Line alpha="0.1" x="30" width="400">
				<s:stroke>
					<s:SolidColorStroke/>
				</s:stroke>
			</s:Line>
		</fx:Component>                                       
		<fx:Component className="RGuideLine">
			<s:Line>
				<fx:Script>
					<![CDATA[
						import com.vstyran.transform.utils.TransformUtil;
						
						import mx.core.UIComponent;
						import spark.components.Group;
						
						public function update(target:UIComponent, passiveGuideGroup:Group):void
						{
							var m:Matrix = TransformUtil.getMatrix(target, passiveGuideGroup);
							
							var stPoimt:Point =  m.transformPoint(new Point(target.width/2, target.height/2));
							var endPoimt:Point =  m.transformPoint(new Point(target.width, target.height/2));
							this.xFrom = stPoimt.x;
							this.yFrom = stPoimt.y;
							this.xTo = endPoimt.x;
							this.yTo = endPoimt.y;
						}
					]]>
				</fx:Script>
				<s:stroke>
					<s:SolidColorStroke color="#AA0000"/>
				</s:stroke>
			</s:Line>
		</fx:Component>                                       
	</fx:Declarations>               
	
	<s:BorderContainer id="id_border_container" width="100%" height="100%" contentBackgroundAlpha="0"
					   backgroundImage="{viewBackgroundImage}"
					   >
		<components:HW_List_Cert id="id_list" change="id_list_changeHandler(event)"/>
		
		<s:Image id="id_image_instruction" x="200" y="60"/>
		
		<s:Image id="id_image_frame" x="410" y="190"/>
		<s:BorderContainer id="id_group" x="410" y="190" borderColor="red">
			<s:Image id="id_image_edit"/>
		</s:BorderContainer>
		<s:Image id="id_image_mask" x="410" y="190" enabled="false"/>
		<s:Image id="id_image_guide" x="410" y="190" enabled="false"/>
		
		<view:UITransformTool id="id_uit_tool" skinClass="skins.uiTransformTool.TransformToolSkin3" 
							  transformationComplete="tool_transformationCompleteHandler(event)"
							  guidelinesUpdate="tool_guidelinesUpdateHandler(event)"
							  >
			<!--<view:bounds>
				<model:Bounds x="{id_image_frame.x}" y="{id_image_frame.y}" width="{img_editor_width}" height="{img_editor_height}"/>
			</view:bounds>-->
			<!--<view:guidelines>
				<model:Guideline type="{GuidelineType.HORIZONTAL_CENTER}" value="400" fraction="3"/>
				<model:Guideline type="{GuidelineType.VERTICAL_CENTER}" value="300" fraction="3"/>
			</view:guidelines>-->
			
		</view:UITransformTool>
		
		<s:Button x="383" y="500" label="RE_UPLOAD" skinClass="skins.button.HW_Back2UploadButton_Skin" click="reupload_button_clickHandler(event)"/>
		<s:Button x="505" y="500" label="EDIT_NEXT" skinClass="skins.button.HW_EditorNextButton_Skin" click="editnext_button_clickHandler(event)"/>
		<spark:HSlider id="id_hslider_rotate" x="393" y="438" 
					   showTrackHighlight="true" skinClass="skins.slider.HW_EditorRotateHSlider_Skin"
				   change="onEditorRotateSliderChange(event)" stepSize="5" minimum="-360" maximum="360" value="0"
				   width="200" 
				   />
		<s:Button x="349" y="425" label="ROTATE" skinClass="skins.button.HW_RotateButton_Skin" click="rotate90ButtonClickHandler(event)"/>
		<s:Button x="625" y="198" label="ZOOM_IN" skinClass="skins.button.HW_ZoomInButton_Skin" click="zoomInButtonClickHandler(event)"/>
		<s:Button x="625" y="373" label="ZOOM_OUT" skinClass="skins.button.HW_ZoomOutButton_Skin" click="zoomOutButtonClickHandler(event)"/>
		<spark:VSlider id="id_vslider_scale" x="638" y="230"
					   showTrackHighlight="true" skinClass="skins.slider.HW_EditorScaleVSlider_Skin"
				   change="onEditorScaleSliderChange(event)" stepSize="0.1" minimum="0.1" maximum="2" value="1"
				   height="140" 
				   />
		
		
		<s:Group id="passiveGuideGroup" top="0" bottom="0" left="0" right="0"/>
		<s:Line id="vGuide" yFrom="45" yTo="275" depth="3" visible="false">
			<s:stroke>
				<s:SolidColorStroke color="#AA0000"/>
			</s:stroke>
		</s:Line>
		<s:Line id="hGuide" xFrom="30" xTo="430" depth="3" visible="false">
			<s:stroke>
				<s:SolidColorStroke color="#AA0000"/>
			</s:stroke>
		</s:Line>
	</s:BorderContainer>
</views:ViewBase>
